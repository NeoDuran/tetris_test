<style>
    #next-piece {
        border: 2px solid black;
        width: 120px;
        height: 120px;
        position: relative;
        margin-left: 20px;
        display: inline-block;
    }
    
    #next-piece .block {
        position: absolute;
        width: 30px;
        height: 30px;
        border: 1px solid white;
    }
</style>

<script>
// 오디오 객체 생성 및 볼륨 조절
const moveSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3');
const clearSound = new Audio('https://assets.mixkit.co/active_storage/sfx/1667/1667-preview.mp3');
moveSound.volume = 0.3;
clearSound.volume = 0.3;

function drawBoard() {
    // 기존 게임 보드 그리기
    const gameBoard = document.getElementById('game-board');
    gameBoard.innerHTML = '';
    
    // 보드의 기존 블록들 그리기
    board.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value) {
                const block = document.createElement('div');
                block.className = 'block';
                block.style.backgroundColor = value;
                block.style.left = x * BLOCK_SIZE + 'px';
                block.style.top = y * BLOCK_SIZE + 'px';
                gameBoard.appendChild(block);
            }
        });
    });

    // 현재 움직이는 블록 그리기
    if (currentPiece) {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    block.style.backgroundColor = currentPiece.color;
                    block.style.left = (currentPiece.x + x) * BLOCK_SIZE + 'px';
                    block.style.top = (currentPiece.y + y) * BLOCK_SIZE + 'px';
                    gameBoard.appendChild(block);
                }
            });
        });
    }

    // 다음 블록 그리기
    const nextBoard = document.getElementById('next-piece');
    nextBoard.innerHTML = '';
    if (nextPiece) {
        nextPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    block.style.backgroundColor = nextPiece.color;
                    // 다음 블록을 중앙에 위치시키기 위한 오프셋 계산
                    const offsetX = (120 - nextPiece.shape[0].length * BLOCK_SIZE) / 2;
                    const offsetY = (120 - nextPiece.shape.length * BLOCK_SIZE) / 2;
                    block.style.left = (x * BLOCK_SIZE + offsetX) + 'px';
                    block.style.top = (y * BLOCK_SIZE + offsetY) + 'px';
                    nextBoard.appendChild(block);
                }
            });
        });
    }
}

function mergePiece() {
    if (!currentPiece) return;
    
    currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value) {
                board[y + currentPiece.y][x + currentPiece.x] = currentPiece.color;
            }
        });
    });
    
    // 효과음 재생
    moveSound.currentTime = 0;
    moveSound.play();
    
    clearLines();
    currentPiece = null;
}

function clearLines() {
    let linesCleared = 0;
    
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (board[y].every(cell => cell)) {
            board.splice(y, 1);
            board.unshift(Array(BOARD_WIDTH).fill(0));
            linesCleared++;
            y++;
        }
    }
    
    if (linesCleared > 0) {
        // 효과음 재생
        clearSound.currentTime = 0;
        clearSound.play();
        
        score += linesCleared * 100;
        document.getElementById('score').textContent = score;
    }
}

// moveDown 함수에도 효과음 추가
function moveDown() {
    currentPiece.y++;
    if (collision()) {
        currentPiece.y--;
        mergePiece();
    }
    drawBoard();
}
</script>
